\section{Architectural Design}
This section exposes \myTaxiService{} Architectural Design in a complete e comprehensible way.

\subsection{Overview}
%TODO descrizione del disegno dell'architettura generale(vedi rasd quasi uguale)
A quick but meaningful overview on the system architectural design is presented with the help of the following diagram, which is self explanatory:
\showGeneralDiagram{Overview Diagram}{1.0}
In addition are given many \textbf{UML Diagrams} integrated with complete descriptions of the software components in the following subsections:
\begin{itemize}
	\itemBold{Component View} Describes the division of the system in \textbf{Layers} and how the work flow is organized through them. It contains a \textbf{UML Component Diagram} that best delivers a comprehensive overlook.
	\itemBold{Deployment View} Explains how the division of system in \textbf{Tiers} is done with the help of an \textbf{UML Deployment Diagram}.
	\itemBold{Runtime View} Describes how each software components interacts with each other. To better explain the method call order and which component is used to obtain a given functionality, a set of \textbf{UML Sequence Diagram} is presented.
\end{itemize}

\subsection{High level components and their interaction}
In the following section are deeply covered all the architectural aspects that characterize the software to be.
In particular, here it is explained at a high level of abstraction how is designed the division of the system into \textbf{Layers} and \textbf{Tiers}.

\subsubsection{Layers}
The software architecture that has been chosen follows the principles of the \textbf{Model View Controller} architectural pattern.
Therefore three main software components have been identified and those are without any coup de theatre: the \textbf{Model}, the \textbf{View} and the \textbf{Controller}.
As already mentioned and explained through the \textbf{Overview Diagram}, the system has many distributed components: those will communicate with a \textbf{Client-Server} style and through \textbf{Point to Point} messaging system.
The \textbf{Client-Server} style is used in order to receive different requests (e.g. a \textbf{Taxi Reservation} request) from the many \textbf{Clients} connected to the \textbf{Server} to use the service.
The \textbf{Point to Point} bidirectional communication channel is made necessary to enable the \textbf{Server} the delivery of various messages and requests to the \textbf{Clients}.
These message could be generic notifications and service messages, or in the particular case in which the connected client is a \textbf{Taxi Driver}, the request of serving a \textbf{Taxi Ride} and the request of an updated \textbf{GPS Data}.

\textbf{Model, View and Controller} are then mapped to three different relevant \textbf{Layers}:

\paragraph{View}
The role of this \textbf{Layer} is the one of processing remote \textbf{Clients} commands, and convert them into requests addressed to the \textbf{Controller} layer, that is connected to the \textbf{View} through a communication facility (e.g. The Internet).
There exists four different types of \textbf{View}, each one designed specifically for the particular \textbf{Client}:
\begin{itemize}
	\itemBold{Passenger Web View} Interface developed for the \textbf{Passengers}, accessible via a \textbf{Web Browser}.
	\itemBold{Passenger Application View} Interface developed for the \textbf{Passengers}, accessible via a dedicated \textbf{Mobile Application}.
	\itemBold{Taxi Driver Application View} Interface developed for the \textbf{Taxi Drivers}, accessible via a dedicated \textbf{Mobile Application}.
	\itemBold{Administrator View} Interface developed for \myTaxiService{} \textbf{Administrator}, accessible via the dedicated \textbf{Administrator Workstation}.
\end{itemize}

\paragraph{Controller}
This second \textbf{Layer} is composed itself of two families of components with specialized functionalities:
\begin{itemize}
	\itemBold{Networking Components Family} This family groups the software components that are involved in sending messages to the various \textbf{Views}, following the logic implements in the \textbf{Business Components Family}.
	This is also the entry point for requests generated by the \textbf{Views}, that are then dispatched to the various business components.
	\itemBold{Business Components Family} In this family are included all the software components that implement the system logic, processing requests and generating responses and asynchronous events.
\end{itemize}

\paragraph{Model}
The third and last \textbf{Layer} is the \textbf{Model}, that should guarantee a high level interface to store and manage all the \myTaxiService{} relevant data.
It abstracts a \textbf{Relational Database} to a software components that is in direct connection to the \textbf{Controller}.

\subsubsection{Tiers}
Then it comes the division of the software in different \textbf{Tiers}:
\begin{itemize}
	\itemBold{Clients} The distributed clients of the application. The \textbf{View} layer is mapped only to this \textbf{Tier}.
	\itemBold{Web Server} A server that is in charge of dynamically generate web pages and receive requests through the web. It is also the server where are hosted the \textbf{Assets} of the web portal. The \textbf{Networking Components Family} of the \textbf{Controller} is mapped to this \textbf{Tier}.
	\itemBold{Application Server} This is the most important \textbf{Tier} of the system. Here are done all the logics and calculations that constitute the core part of \myTaxiService{}. The \textbf{Business Components Family} is hosted on this server and therefore it is a part of the \textbf{Controller} that is separated from the \textbf{Web Server}. It is necessary to have the \textbf{Controller} divided into two different \textbf{Tiers} in order to separate the most important software parts, that are the business logic components, from the network components, for security concerns.
	\itemBold {Database Server}
	In this \textbf{Tier} it is hosted the \textbf{Database} that allows the service data persistence. The \textbf{Model} layer is entirely mapped to this \textbf{Tier}.
\end{itemize}

This architecture, with three different \textbf{Layers} and four different \textbf{Tiers}, makes possible to have a \textbf{Client-Server} style with a \textbf{Fat-Server} and a \textbf{Thin-Client}: this is due to the mapping of the \textbf{View} to the \textbf{Clients} and the mapping of the \textbf{Controller} and the \textbf{Model} to the \textbf{Server}.

\subsection{Component view}
%TODO TRADURRE
%TODO inserire il component diagram e spiegare ogni componente che scopo ha e dove sta (dispatcher e restful service sono su web server e locationmanager ). spiegazione dei layer software
\showComponentDiagram{UML Component Diagram}{1.0}
Di seguito sono descritti i sub-components che interoperano all'interno di ogni component e le interfaces interne che permettono loro di comunicare uno con l'altro.
\begin{itemize}
	\itemBold{Passenger View}
	In questo componente sono raggruppati i seguenti sotto componenti:
	\begin{itemize}
		\itemBold{PS Application View and PS Web View} Sono i componenti software che permettono di intercettare gli eventi di interazione tra software e utente finale, come ad esempio click di un pulsante o lo scroll. 
		Inoltre sono in grado di mostrare i dati di risposta ricevuti via rete.
		\itemBold{PS Request Creator} Tramite questo componente viene effettuato un mapping completo tra eventi performabili dall'utente sulla \textbf{Application o Web View} e richieste da inviare al server. 
		E' un componente \textbf{Observer} che si risveglia quando un evento è generato e lo traduce in una richiesta ben formata. 
		\itemBold{PS Receiver} Tramite questo componente vengono tradotte le risposte in eventi di ritorno.
		E' un componente \textbf{Observable} del quale la \textbf{View} si registra come \textbf{Listener}.
	\end{itemize}
	\itemBold{Taxi Driver View}
	In questo componente sono raggruppati i seguenti sotto componenti:
	\begin{itemize}
		\itemBold{TD Application View} E' il componente software che permette di intercettare gli eventi di interazione tra software e il \textbf{Taxi Driver}, come ad esempio click di un pulsante o lo scroll. 
		Inoltre è in grado di mostrare i dati di risposta ricevuti via rete.
		\itemBold{TD Request Creator} vedi \textbf{PS Request Creator}.
		\itemBold{TD Receiver} vedi \textbf{PS Receiver}
		\itemBold{TD Locator} E' il componente software che ha accesso all'interfaccia con il GPS dello smartphone del \textbf{Taxi Driver} e che, una volta invocato dal \textbf{Location Manager}, può richiedere al GPS la posizione di un determinato tassista. 
		E' fondamentale nel momento in cui il server, per avere una modello sempre consistente con la posizione reale dei tassisti, invia richieste di aggiornamento del mapping tra tassita e zona della città.
	\end{itemize}	
	\itemBold{Taxi Driver Model}
	In questo componente sono raggruppati i seguenti sotto componenti:
	\begin{itemize}
		\itemBold{GPS Data Source} E' un oggetto che rappresenta la posizione più recente inviata dal segnale GPS; è composto da molti dati, tra i quali i più imporntanti sono \textbf{Latitudine} e \textbf{Longitudine}.
		Infatti tramite questi dati è possibile determinare univocamente la posizione del \textbf{Taxi Driver}.
	\end{itemize}
	
	\itemBold{Controller}
	In questo componente sono raggruppati i seguenti sotto componenti:
	\begin{itemize}
		\itemBold{RESTful Service} Questo \textbf{Software Component} si occupa di ricevere le richieste dai \textbf{Client} e le distribuisce ai vari \textbf{Manager Components} appartententi alla \textbf{Busines Family}. 
		Inoltre garantisce che vengano gestite un numero massimo, prefissato e configurabile di richieste in parallelo.
		Per permettere agli altri \textbf{Software Components} di interagire espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Receive TD Request} Permette ai \textbf{Client} di inviare le richieste.
			\itemBold{Receive PS Request} vedi \textit{Receive TD Request}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Login} Utilizzata per gestire una richiesta di login proveniente dal PS.
			\itemBold{Logout} Utilizzata per gestire una richiesta di logout proveniente dal PS.
			\itemBold{Register} Utilizzata per gestire una richiesta di registrazione proveniente dal PS.
			\itemBold{Modify Profile} Utilizzata per gestire una richiesta di modifica del profilo proveniente dal PS.
			\itemBold{Report Problem} Utilizza questa interfaccia per gestire una richiesta di report problem proveniente dal TD.
			\itemBold{Add Taxi Ride} Utilizza questa interfaccia per gestire una richiesta di Taxi Ride proveniente dal PS.
			\itemBold{Remove Taxi Ride} Utilizza questa interfaccia per gestire una richiesta di cancellazione della Taxi Ride proveniente dal PS.
		\end{itemize}

		\itemBold{Dispatcher} Questo \textbf{Software Component} si occupa di dispacciare i messaggi di notifica, di sistema, di associazione tra \textbf{Taxi Ride} e \textbf{Taxi Driver} dal \textbf{Server} verso il relativo \textbf{Client}.
		Per permettere agli altri \textbf{Software Components} di interagire espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Dispatch Message} Permette ai componenti interni al \textbf{Controller} di inviare messaggi ai \textbf{Client}. 
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Receive PS Update} Utilizza questa interfaccia per permettere ai \textbf{Clients} di ricevere messaggi provenienti dai componenti interni al \textbf{Controller}.
			\itemBold{Receive TD Update} vedi \textit{Receive TD Update}.	
		\end{itemize}
		
		\itemBold{Location Manager} Questo \textbf{Software Component} espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Get Zone From Address} Permette di associare una \textit{city zone} a partire da un \textit{city address}, utile quando bisogna categorizzare una \textbf{Taxi Ride} appena arrivata.
			\itemBold{Get TD Address} Fornisce la funzionalità per richiedere ad un \textbf{Taxi Driver} il \textit{actual city address}, per aggiornare la mappa interna al server tra \textbf{Taxi Driver} e \textbf{City Address}.
			\itemBold{Compute Travel Time} Permette di calcolare il tempo di percorrenza tra due \textit{city addresses}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Get TD Position} Utilizza questa interfaccia per richiedere la posizione GPS al \textbf{Taxi Driver} che viene scelto dal \textbf{Taxi Driver Manager}.
			\itemBold{Google Maps API} Utilizza questa interfaccia per effettuare le richieste necessarie per calcolare il \textbf{Travel Time} e per associare un indirizzo ai dati GPS.	
			\itemBold{Query Zone Model} Utilizza questa interface per richiedere al \textbf{Model} la zona che corrisponde ad un certo dato GPS che viene fornito dal \textbf{Taxi Driver}. 
			Questa interface viene utilizzata dopo la chiamata all'interface \textbf{Get TD Position}.
		\end{itemize}
		
		\itemBold{Queue Manager} Questo \textbf{Software Component} si occupa di :
		\begin{itemize}
			\item Gestire le code dei \textbf{Taxi Driver}, una coda per zona della città.
			\item Genera i messaggi di notifica ,contenenti \textit{Taxi Driver ID} e \textit{Travel Time}, da inviare ai \textbf{Passenger} nel momento in cui la richiesta che hanno fatto viene accettata da un \textbf{Taxi Driver}. 
			Per fare questo deve chiamare il \textbf{Location Manager} e richiedere il \textbf{Travel Time}.
			\item Provvede a cambiare la coda del \textbf{Taxi Driver} che ha cambiato zona.
			\item Ridistribuisce le\textbf{Taxi Ride}. Infatti quando viene servita una richiesta di \textbf{taxi rideTaxi Ride} associata ad una zona la cui relativa coda è vuota, scatta un timeout dopo la scadenza del quale la taxi ride viene ridistribuita in una delle code delle zone ad essa limitrofe.
		\end{itemize}
		Per performare queste funzionalità il \textbf{Queue Manager} espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{TD Zone Changed} Permette di cambiare coda ad un certo \textbf{Taxi Driver}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Query Queue Model} Utilizza questa interfaccia sul \textbf{Model} per spostare un \textbf{Taxi Driver} da una coda ad una altra coda quando quest'ultimo ha cambiato zona. 
			Inoltre questa interface ha un metodo per prelevare un \textbf{Taxi Driver} da una coda per associarlo ad una \textbf{Taxi Ride}.
			\itemBold{Compute Travel Time} Utilizza questa interfaccia per richiedere al \textbf{Location Manager} il \textbf{Travel Time} relativo ad una \textbf{Taxi Ride} che sta servendo.
			\itemBold{Dispatch Message} Utilizza questa interfaccia per inviare una notifica per confermare l'associazione di una \textbf{Taxi Ride} con un \textbf{Taxi Driver}.
		\end{itemize}
		
		\itemBold{Session Manager} E' il componente software che si occupa di modificare il modello relativo alle sessioni attive degli utenti di \myTaxiService{}.
		Per performare queste funzionalità il \textbf{Session Manager} espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Login} Permette di cambiare iniziare la procedura di login per un utente di \myTaxiService{}.
			\itemBold{Logout} Permette di cambiare iniziare la procedura di logout per un utente di \myTaxiService{}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Query Passenger Model} Utilizza questa interfaccia sul \textbf{Model} per modificare il modello aggiungendo una sessione per il \textbf{Passenger} che ha chiesto di fare login e restituendo un Token che identifichi la sessione appena aperta.
			\itemBold{Query Taxi Driver Model} Utilizza questa interfaccia sul \textbf{Model} per modificare il modello aggiungendo una sessione per il \textbf{Taxi Driver} che ha chiesto di fare login e restituendo un Token che identifichi la sessione appena aperta.
		\end{itemize}
		
		\itemBold{Profile Manager} Si occupa di modificare la porzione del modello relativa al profilo degli utenti registrati a \myTaxiService{}.
		Per performare queste funzionalità il \textbf{Profile Manager} espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Register} Permette di effettuare la registrazione a \myTaxiService{}.
			\itemBold{Modify Profile} Permette di modificare un profilo precedentemente creato presso \myTaxiService{}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Query Passenger Model} Utilizza questa interfaccia sul \textbf{Model} per modificare il modello aggiungendo un utente registrato o modificare il profilo di un utente precedentemente registrato.
		\end{itemize}

		\itemBold{Taxi Driver Manager} Si occupa di gestire tutto ciò che riguarda i \textbf{Taxi Driver}. 
		Questo componente è molto importante perchè ha il compito di richiedere periodicamente  la posizione ai \textbf{Taxi Drivers} in modo tale da garantire che il modello sia sempre aggiornato e consistente.
		In particolare espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Report Problem} Permette ad un \textbf{Taxi Driver} di notificare l'avvenimento di un problema durante una \textbf{Taxi Ride} o di notificare che un certo probema è stato risolto.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{TD Zone Changed} Utilizza questa \textit{interface} per notificare al \textbf{Queue Manager} di spostare un \textbf{Taxi Driver} da una coda ad un'altra perchè il relativo \textbf{Taxi Driver} ha cambiato zona. Il \textbf{Queue Manager} avrà anche il compito di aggiornare il modello.
			\itemBold{Query Taxi Driver Model} Utilizza questa \textit{interface} sul \textbf{Model} nei seguenti casi: 
			\begin{itemize}
				\item Utilizza questa interface dopo la terminazione della procedura di aggionamento dell'indirizzo di un \textbf{Taxi Driver} per garantire la \textbf{Consistency} e la \textbf{Durability} del \textbf{Database}.
				\item Utilizza questa interface per aggiungere un problema alla lista dei problemi.
				\item Utilizza questa interface per marcare un problema come risolto.
			\end{itemize}
			\itemBold{Dispatch Message} Utilizzata per inviare messaggi personalizzati al \textbf{Taxi Driver}.
			\itemBold{Get TD Address} Utilizza questa interface per inviare una richiesta di posizione al \textbf{Taxi Driver} che è stato selezionato.
		\end{itemize}
		
		\itemBold{Taxi Ride Manager} Si occupa di gestire tutto ciò che riguarda le \textbf{Taxi Ride}.
		In particolare espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Add Taxi Ride} Permette al \textbf{RESTful Service} di aggiungere una \textbf{Taxi Ride} alla lista di \textbf{Taxi Ride} contenuta nel \textbf{Model}.
			\itemBold{Remove Taxi Ride}Permette al \textbf{RESTful Service} di rimuovere una \textbf{Taxi Ride} dalla lista di \textbf{Taxi Ride} contenuta nel \textbf{Model}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Get Zone From TD Address} Permette di associare la zona ad una \textbf{Taxi Ride} appena arrivata in modo tale da categorizzarla e in modo tale da renderla associabile ad un \textbf{Taxi Driver}.
			\itemBold{Query Taxi Ride Model} Permette di aggiungere o di rimuovere una \textbf{Taxi Ride} dalla lista di \textbf{Taxi Ride} contenuta nel \textbf{Model}.
		\end{itemize} 
		
		\itemBold{Taxi Sharing Manager}
		This component is in charge of managing the Taxi Sharing future 
		In particolare espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{myTaxiSharing API} Permette agli sviluppatori esterni di utilizzare le API predefinite  di \textbf{Taxi Sharing} fornite da \myTaxiService{}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Query Shareable Taxi Ride} Utilizza questa \textit{interface} per richiedere al \textbf{Model} le \textbf{Taxi Ride} che è possibile rendere disponibili a più utenti. 
			Il risultato di questa query sarà utilizzato per costriuire le API pubbliche.
		\end{itemize}
		
		\itemBold{Query Manager}
		In particolare espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Query Queue Model} Permette al \textbf{Queue Manager} di modificare e leggere lo stato delle code memorizzate nel \textbf{Model}.
			\itemBold{Query Zone Model} Permette al \textbf{Location Manager} di richiedere l'esecuzione dell'algoritmo di ricerca di una posizione GPS all'interno di una  determinata zona.
			\itemBold{Query Passenger Model} Permette al \textbf{Session Manager} e al \textbf{Profile Manager} di modificare e leggere lo stato dei dati relativi agli utenti memorizzati nel \textbf{Model}.
			\itemBold{Query Taxi Driver Model} Permette al \textbf{Taxi Driver Manager} di modificare e leggere lo stato dei dati relativi ai \textbf{Taxi Driver} memorizzati nel \textbf{Model}.
			\itemBold{Query Taxi Ride Model} Permette al \textbf{Taxi Ride Manager} di modificare e leggere lo stato dei dati relativi alle corse memorizzate nel \textbf{Model}.
			\itemBold{Query Shareable Taxi Ride} Permette al \textbf{Taxi Sharing Manager} di performare query predefinite di lettura sulle \textbf{Shareable Taxi Ride} memorizzate nel \textbf{Model}.
			\itemBold{Administrator Queries} Permette all \textbf{Administrator} di performare query predefinite per analizzare lo stato interno del sistema.
			Inoltre sono rese possibili speciali query di ripristino del sistema.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Query Model} Utilizza questa interface per chiamare query predefinite sul \textbf{Model} in modo tale da eseguire le procedure di aggiornamento del \textbf{Model} richieste.
		\end{itemize}
	\end{itemize}
	
	\itemBold{Model}
	In this component are included the following subcomponents:
	\begin{itemize}
		\itemBold{Model Query Service}
		This component provides an aggregated interface rich of methods to access the relational model underlying with a high level of abstraction, protection and security.
		The interface that it implements is called Query Model and it is used by the Query Manager to query the model via RPC.
		\itemBold{Passenger DB Adapter}
		It is a utility component that implements and exposes Passenger related query methods, built above the Query Database interface to the Database Driver Adatper.
		\itemBold{Taxi Ride DB Adapter}
		It is a utility component that implements and exposes Taxi Ride related query methods, built above the Query Database interface to the Database Driver Adatper.
		\itemBold{Taxi Driver DB Adapter}
		It is a utility component that implements and exposes Taxi Driver related query methods, built above the Query Database interface to the Database Driver Adatper.
		\itemBold{Zone DB Adapter}
		It is a utility component that implements and exposes Zone related query methods, built above the Query Database interface to the Database Driver Adatper.
		\itemBold{Queue DB Adapter}
		It is a utility component that implements and exposes Queue related query methods, built above the Query Database interface to the Database Driver Adatper.
		\itemBold{Database Driver Adapter}
		This component is a wrapper built on the Database Driver (that can be JDBC) that provides a set of methods to perform the common operations that could be done on a relational database.
		In fact it connects to the Database Management System via a Database Driver.
		Those methods are exposed in a interface that is called Query Database, and the various DB Adapters calls them in a way that depends on the caller component itself.
	\end{itemize}
\end{itemize} 

\subsection{Deployment view}
%TODO inserire il deployment diagram (spiega la suddivisione in tier). spiegazione dei tier hardware
\showDeploymentDiagram{UML Deployment Diagram}{1.0}

\subsection{Runtime view}
%TODO You can use sequence diagrams to describe the way components interact to accomplish specific tasks typically related to your use cases.
\showSequenceDiagram{admin_td_reg}{UML Sequence Diagram - TD Registration}{1.0}
\showSequenceDiagram{ps_registration}{UML Sequence Diagram - PS Registration}{1.0}
\showSequenceDiagram{ps_login}{UML Sequence Diagram - PS Login}{1.0}
\showSequenceDiagram{queue}{UML Sequence Diagram - Queue Management}{1.0}
\showSequenceDiagram{taxi_ride_arrived_handling}{UML Sequence Diagram - Taxi Ride Handling}{1.0}
\showSequenceDiagram{tr_timer_expired}{UML Sequence Diagram - Taxi Reservation Timer Expired}{1.0}
\subsection{Component interfaces}
Being our system composed of different software components that need to interact together, several interfaces have been put among them.
Subsequently are listed all the main software components and their interfaces, each one described in detail:
\begin{itemize}
	\itemBold{Passenger View}
	This component implements 1 interface:
	\begin{itemize}
		\itemBold{Receive PS Update} An interface over the \textbf{Web Socket} technology that is implemented by the \textbf{Passenger View} and called by the \textbf{Controller} in order to deliver updates to a particular Passenger.
		It is required that a \textbf{Web Socket} is opened by the \textbf{Passenger View} to the \textbf{Controller} in order to permit the last one the sending of messages.
		Message delivery is intended to be asynchronous but in some cases the \textbf{Controller} waits the \textbf{Passenger View} to respond with some kind of information to a particular message sent to it, and in this case the communication is synchronous.
	\end{itemize}
	This component utilizes 1 interface:
	\begin{itemize}
		\itemBold{Receive PS Request} An interface implemented by the \textbf{Controller} that exposes the necessary methods to build up a \textbf{RESTful Service} over the \textbf{HTTPS} protocol.
		Through this interface the \textbf{Passenger View} can send specific requests to the \textbf{Controller}, that synchronously responds with the necessary information.
	\end{itemize}
	\itemBold{Taxi Driver View}
	This component implements 2 interfaces:
	\begin{itemize}
		\itemBold{Receive TD Updated} As for the \textbf{Receive PS Update} interface, this interface over \textbf{Web Socket} technology is called by the \textbf{Controller} to deliver messages and requests to a particular Taxi Driver.
		It is required that a \textbf{Web Socket} is opened by the \textbf{Taxi Driver View} to the \textbf{Controller} in order to permit it to send messages.
		The delivery of message is asynchronous when a direct answer by the \textbf{Taxi Driver View} is not needed, in other cases the \textbf{Controller} makes a synchronous call to the \textbf{Taxi Driver View} and waits for it to send back the desired data.
		\itemBold{Get TD Position} This interface over \textbf{Web Socket} is called synchronously by the \textbf{Controller} to get the last position registered in the \textbf{Taxi Driver View}.
		This could be a crucial part of the system and therefore it is intended that no Taxi Driver hacks his own smartphone GPS location system in order to deliver wrong position (maybe introducing an important fee to be paid in case of this misbehaviour).
		The \textbf{Taxi Driver Web} must open a \textbf{Web Socket} connection to the \textbf{Controller} in order to permit him to ask the position.
	\end{itemize}
	This component utilizes 2 interfaces:
	\begin{itemize}
		\itemBold{Receive TD Request} An interface over \textbf{HTTPS} that is implemented by the \textbf{Controller} and like the \textbf{Receive PS Request} does for the Passenger, allows the Taxi Driver to send request to the \textbf{Controller}, while waiting synchronously for a response.
		\itemBold{Get GPS Data} An interface implemented by the \textbf{Taxi Driver Model}, and is used to obtain the latest valid GPS position when the \textbf{Controller} asks for it via the \textbf{Get TD Position} interface.
		It can be easily seen as an abstraction over the operating system GPS drivers.
	\end{itemize}
	\itemBold{Taxi Driver Model}
	This component implements 1 interface:
	\begin{itemize}
		\itemBold{Get GPS Data} That is the interface offered to the \textbf{Taxi Driver View} and it is needed to obtain the most recent GPS position located by the GPS antenna installed in the Taxi Driver smartphone.
		In facts it wraps up the operating system GPS drivers in order to deliver a clean and meaningful interface to be utilized in the system to be.
	\end{itemize}
	\itemBold{Administration View}
	This component utilizes 1 interface:
	\begin{itemize}
		\itemBold{Administrator Queries} This interface is provided by the \textbf{Controller} via \textbf{RPC} technology (whose implementation could be \textbf{RMI}) and allows the \textbf{Administrator View} to perform some crucial activities and queries on the \myTaxiService{} model in a more direct and powerful way. Through this interface it is allowed the registration of a new Taxi Driver.
		This interface is not intended to be publicly accessible, and therefore it is better not to expose it through a public IP.
		In addition, it is intended that the Administrators are trained personnel and are very discouraged to damage or break the system they are interacting with.
	\end{itemize}
	\itemBold{Model}
	This component implements 1 interface:
	\begin{itemize}
		\itemBold{Query Model} It is an interface over \textbf{RPC} technology (could as well be \textbf{RMI}) that allows the \textbf{Controller} to do all kind of interesting relational queries on the \myTaxiService{} model, through a set of exposed and controlled methods.
		It abstracts the concept of relational query to a higher level of usability and security.
		The model to which the interface refers is at its core a relational database, that is accessed through a \textbf{Database Driver Adapter}, that could wrap up a database driver like \textbf{JDBC}.
	\end{itemize}
	\itemBold{Controller}
	This is the central part of \myTaxiService{} system and has the greatest number of implemented and utilized interfaces.
	It implements 4 different interfaces:
	\begin{itemize}
		\itemBold{myTaxiSharing API} This interface provided through \textbf{HTTPS} is intended to be utilized by the developers that wants to further develop \myTaxiService{}, adding the Taxi Sharing capability.
		It is not intended to be accessible publicly and therefore it must be protected using firewalls and access control management, with credential authentication.
		A developer that wants to utilize the API, must request the permission to the Administrator, that creates valid credentials, configures the system accordingly, and communicate to him/her those credentials.
		\itemBold{Receive PS Request} Already presented above in \textbf{Passenger View} interfaces analysis.
		\itemBold{Receive TD Request} Already presented above in \textbf{Taxi Driver View} interfaces analysis.
		\itemBold{Administrator Queries} Already presented above in \textbf{Administrator View} interfaces analysis.
	\end{itemize}
\end{itemize}

\subsection{Selected architectural styles and patterns}
%TODO Grassetti e a capo
Several architectural styles and patterns were chosen in order to build \myTaxiService{} as a modern software.
The main pattern that were recursively adopted is the Model View Controller architectural pattern:
\begin{itemize}
	\itemBold{System Level} All the clients that use \myTaxiService{}, the Passengers, the Taxi Drivers, and the Administrator, are seen as Views, that following the Cocoa MVC pattern, connects to a Controller, the Web Server or the Application Server, that is itself connected to the Model that is hosted on the Database Server.
	\itemBold{Client Level} The views in the various clients are designed internally to conform to the MVC pattern. For instance the Passenger View is composed by a Model that is an internal representation of the data received by the Web Server, a Controller that performs network activities and connects to the Model and to the View, and the View that is either a Mobile Application GUI or a Web Page.
	\itemBold{Server Level} The server part of \myTaxiService{} is divided also physically into the three different entities of the MVC pattern:
	\begin{itemize}
		\itemBold{Web Server} It is the View of the server part of the application, and gives to clients a representation of the internal data. The Web Server is connected only to the Application Server. It contains all the assets included in the web portal. On its external interface, it can handle properly HTTPS requests and manage communication over Web Sockets. On its internal interface it sends and receives objects via RPC from the Application Server, that is in charge of the application logic.
		\itemBold{Application Server} That is the Controller of the server and connects to the Web Server and the Database Server via RPC. It contains most of the business logic behind \myTaxiService{} and therefore it is a core part of the system. It should be reachable only within the enterprise network, and not via public IP. The connection to the Web Server is used to receive requests and deliver responses to clients and to send asynchronous requests to them, when it is needed. On the other hand, the connection to the Database Server is necessary to connect the Controller to the Model, and it is used to store all the important data and react to some data modifications that occurs during the execution of the application.
		\itemBold{Database Server} It is the Model of the server, and infact the Model of the whole \myTaxiService{} system. It relies on an RPC connection with the Application Server and it is not directly reachable via a public IP. The Database Server is connected to a relational database via a Database Driver Adapter, that is a wrapper built over the DBMS installed on the Database Server Operating System. Following the Cocoa MVC pattern, it is not directly connected to the View of the server, that is the Web Server, but only to the Controller, that is the Application Server.
	\end{itemize}
\end{itemize}
Alongside the MVC architectural pattern, also the Client Server style is used for all the requests done by the various clients that can connect to the Web Server of \myTaxiService{}. The Taxi Driver Application and the Passenger Application can use a standardized Client Server protocol via HTTPS that is follows the principle of a RESTful service. The Administrator application its connected via RPC to the Web Server and can perform more critical requests, like the registration of a new Taxi Driver into the system. It is required that the Administrator application opens a RPC connection to the server to start the communication.
A Point to Point bidirectional messaging system is established between the clients and the Web Server at the startup of the client application. The client should explicitly request a connection to the server that is listening for clients to connect. It is a connection over Web Socket that allows the Web Server to send asynchronous messages and requests to which the client can respond using the same channel. It's main functions are the one that allows the server to send a Taxi Ride proposal to a given Taxi Driver, that can either accept or deny the proposal, and the one that allows the server to ask the Taxi Driver an updated geolocalization data.
The Client Server style and Point to Point bidirectional messaging system are used to implement properly the MVC pattern in this three layers, four tiers system.
The three layers have already been discussed and are:
\begin{itemize}
	\itemBold{Data Layer} That is the System Level Model
	\itemBold{Business Logic Layer} That is the System Level Controller
	\itemBold{Presentation Layer} That is the System Level View
\end{itemize}
These layer, as already said, are mapped into four different tiers:
\begin{itemize}
	\itemBold{Clients} They map the System Level View.
	\itemBold{Web Server} It maps a portion of the System Level Controller, that is the one of the RESTful Service, Dispatcher, and part of the Location Manager, onto software objects that provide the required network capabilities.
	\itemBold{Application Server} This tier maps the purely logic part of the System Level Controller.
	\itemBold{Database Server} It maps the System Level Model.
\end{itemize}

\subsection{Other design decisions}
%TODO Grassetti e a capo
There have been chosen several technologies that best fit the needs of the system to be. Not all the required functionalities of \myTaxiService{} are already mapped onto specific products because in those cases the choice done would matter less.
But for the cases in which a technology has already been proposed, it is because a clear design decision was mandatory.
As for the communication protocols between clients (excluded the Administrator client) and the server have been chosen:
\begin{itemize}
	\itemBold{HTTPS} The secure version of HTTP was a mandatory choice as security and privacy concerns are of major importance nowadays.
	\itemBold{Web Socket} This innovative socket technology has been chosen although is relatively new because it implements a full duplex socket communication channel using web technology and therefore using the port 80, which is in almost every case not blocked by any firewall.
\end{itemize}
For what concerns the network reachability has been chosen to make discoverable only the Web Server through the assignment to it of a public IP.
All the other servers in \myTaxiService{} system should be reachable only within the enterprise network.
Between the Web Server and the external network is installed a firewall that controls all the incoming connections.
In particular it must accept only incoming HTTPS connections, Web Socket connections and RPC connections.
A firewall is also used to protected the Database Server from the Application Server in the unlikely case that the Application Server is attacked through the Web Server or the Application Server for some reasons stops working correctly and start behaving in a way that will damage the application Model.
Also, another interesting design choice that has been made concerns the way in which the GPS coordinates obtained from a given Taxi Driver are mapped into a specific Zone.
It could have been possible, but not feasible, to do such a thing:
\begin{enumerate}
	\item Obtain GPS Data via Web Socket from the selected Taxi Driver
	\item Calculate the nearest Address of the given GPS Data using Google Maps HTTPS API
	\item Query the Model to obtain the Zone to which belongs the given Address
\end{enumerate}
But this solution required to have a precomputed data structure that associate every Address in the City to the corresponding Zone (that could have been a relational table with as many tuples inside as Addresses in the City), that is heavy to manage and mantain, although if correctly installed and filled, it gives for certain good performances.
A less heavy weight solution has been found and that is a solution that expects every Zone of the city to be divided in several convex Polygon, for instance Triangles, that have interesting properties for our application.
The polygonal shape of the Zone could be almost as complex as one can imagine and be decomposed in a finite number of Triangles in all the interesting applications.
In \myTaxiService{} Zones of regular shape are intended to be used, and therefore the number of Triangles in which a Zone will be decomposed is limited.
So such a flow is followed:
\begin{enumerate}
	\item Obtain GPS Data via Web Socket from the selected Taxi Driver
	\item For each Zone, check if the the Point that the Longitude and Latitude from GPS Data identify is contained inside any Triangle in which the Zone is divided. If that is true, that the Zone is found. If that is false, than another Zone could contain the given Point. If no Zone contains the Point, then we can assume that the Point refers to GPS Data that locate a geographical point outside of the City.
\end{enumerate}
The computation of the Point in Triangle test is simple and efficient and an algorithm implementation in Java is provided in the following section.
