\section{Architectural Design}
\subsection{Overview}
%TODO descrizione del disegno dell'architettura generale(vedi rasd quasi uguale)
\subsection{High level components and their interaction}
Nella sezione architectural design sono spiegati approfonditamente gli aspetti programmativi che dovranno caratterizzare il software. 
In particolare qui viene spiegato come è stata pensata la suddivisione tra layer e tier, i protocolli di comunicazione scelti e i pattern utilizzati. 
Per chiarificare il più possibile questi aspetti vengono forniti anche numerosi diagrammi UML integrati con esaurienti spiegazioni dei componenti software: 
\begin{itemize}
	\itemBold {Component View} Qui viene descritta la suddivisione in layer e vengono descritti tutti i componenti software tramite i quali viene sviluppato il flusso di lavoro desiderato e viene proposto un UML component diagram per rendere la comprensione piu immediata.
	\itemBold {Deployment View} Qui viene invece descritta la suddivisione in tier e accompagnandla con un UML deployment diagram.
	\itemBold {Runtime View} Qui viene spiegato come i componenti interagiscono l'uno con l'altro. Per spiegare l'ordine di chiamata dei metodi tra i vari componenti vengono forniti gli UML sequence diagrams dei casi più interessanti.
\end{itemize}
\subsubsection{Tier suddivision}
Il software progettato potrà poi fare uso di quattro \textbf{Tier} fisici:
\begin{itemize}
	\itemBold {Passenger Web Browser or Passenger Smartphone} Deve essere garantita la compatibilità del sito web con ogni tipo di \textbf{Browser} ( Safari, Firefox, Opera, IE, Chrome).
	\itemBold {Web Server} Deve essere un sever che si occupa di generare le pagine web dinamicamente e di ricevere le richieste dei passeggeri. Inoltre è il server dove sono hostati gli \textbf{Assets} del sito web. In questa macchina devono essere contenute le \textbf{Classi} relative agli oggetti del \textbf{Server Controller} che ricevono e inviano dati ai \textbf{Client} (Dispatcher, RESTful Service, ...).
	\itemBold {Application Server} Questo è il livello tier sul quale si basa maggiormente l'applicazione. 
	Infatti qui vengono fatti tutti i calcoli e viene contenuta la logica che sta alla base di \myTaxiService{}. 
	E' importante sottolineare che è necessario avere due tier per la gestione delle richieste e delle risposte. Infatti grazie a questa suddivisione le \textbf{Classi} dei componenti software che interagiscono con la rete sono mantenute sul \textbf{Web Server} e quelli che sono di pura logica sono invece hostate nell' \textbf{Application Server}.
	In questo modo si riesce a garantire un ulteriore livello di sicurezza rendendo inaccessibili le porzioni di codice più importanti.
	\itemBold {Database Server} In questo tier è ospitata la base di dati che permette la persistenza dei dati del servizio.
\end{itemize}
\subsubsection{MVC architectural pattern and Layer suddivision}
L'architettura dovrà rispettare il pattern \textbf{MVC (Model View Controller)}, e dovrà rispettare il paradigma di comunicazione \textbf{Client-Server} per la gestione delle richieste generate dalle view dei \textbf{Client} e rivolte al \textbf{Server} per essere gestite. 
E' inoltre necessaria l'implementazione di un canale \textbf{Point to Point} che verrà utilizzato dal \textbf{Server} per poter gestire la necessità di inviare al \textbf{Client} generici messaggi di notifica, messaggi di servizio e, nel caso in cui il \textbf{Client} sia un \textbf{Taxi Driver}, messaggi di associazione con una \textbf{Taxi Ride} e messaggi di richiesta di posizione.
E' quindi necessario implementare tre \textbf{Layer} che garantiscano la stratifcazione necessaria per avere un \textbf{Client Server} con \textbf{Fat Server} e \textbf{Thin Client}.
Guardando l'architettura software ad alto livello, il \textbf{Client} è composto solo dalla \textbf{View}, e per questo motivo si parla appunto di \textbf{Thin Client}. 
Il server invece è suddiviso in due \textbf{Layer}, uno per la parte di \textbf{Controller} e uno per la gestione del \textbf{Model}.
\paragraph{View}
Il ruolo di questo primo \textbf{Layer} è quello di ricevere i comandi dell'utente, generare le richieste da inviare al server e, tramite un sottolivello di comunicazione, inviare le richieste costriute al \textbf{Controller}.
La \textbf{View} può essere di quattro tipi, a seconda dell'utente che la utilizza: 
\begin{itemize}
	\itemBold {Passenger Web View} Interfaccia con \myTaxiService{} rivolta all'utente finale accessibile via browser.
	\itemBold {Passenger Application View} Interfaccia con \myTaxiService{} rivolta all'utente finale accessibile tramite una applicazione dedicata.
	\itemBold {Taxi Driver Application View} Interfaccia con \myTaxiService{} rivolta ai taxisti accessibile tramite applicazione dedicata.
	\itemBold {Admin View} Interfaccia con il \textbf{Web Server Tier} di \myTaxiService{} rivolta all'admin del servizio.
\end{itemize}
\paragraph{Controller}
Il secondo \textbf{Layer} è composto da due famiglie con funzionalità specializzate:
\begin{itemize}
	\itemBold {Networking Family}Questa famiglia comprende quei componenti che si occupano di inviare i messaggi ai vari \textbf{Client}, in base alla logica implementata dai componenti della \textbf{Business Family}.
	Inoltre in questo \textbf{Layer} vengono ricevute le richieste generate dal \textbf{Client} per venire poi smistate agli oggetti della \textbf{Business Family}. 
	\itemBold {Business Family} In questa famiglia sono contenuti componenti che processano le richieste e generano le risposte da inviare al \textbf{Client} tramite i componenti della \textbf{Networking Family}. 
\end{itemize}
\paragraph{Model} 
Il terzo \textbf{Layer} è il \textbf{Model}, il quale deve invece garantire un'interfaccia predefinita con la \textbf{Base di Dati} composta da query predefinite che vengono chiamate dal \textbf{Controller} per aggiornare il modello. 
Inoltre deve essere garantita una rappresentazione dei dati che l'applicazione gestisce tramite \textbf{Modello Relazionale}.
\subsection{Component view}
%TODO inserire il component diagram e spiegare ogni componente che scopo ha e dove sta (dispatcher e restful service sono su web server e locationmanager ). spiegazione dei layer software
Di seguito sono descritti i sub-components che interoperano all'interno di ogni component e le interfaces interne che permettono loro di comunicare uno con l'altro.
\begin{itemize}
	\itemBold{Passenger View}
	In questo componente sono raggruppati i seguenti sotto componenti:
	\begin{itemize}
		\itemBold{PS Application View and PS Web View} Sono i componenti software che permettono di intercettare gli eventi di interazione tra software e utente finale, come ad esempio click di un pulsante o lo scroll. 
		Inoltre sono in grado di mostrare i dati di risposta ricevuti via rete.
		\itemBold{PS Request Creator} Tramite questo componente viene effettuato un mapping completo tra eventi performabili dall'utente sulla \textbf{Application o Web View} e richieste da inviare al server. 
		E' un componente \textbf{Observer} che si risveglia quando un evento è generato e lo traduce in una richiesta ben formata. 
		\itemBold{PS Receiver} Tramite questo componente vengono tradotte le risposte in eventi di ritorno.
		E' un componente \textbf{Observable} del quale la \textbf{View} si registra come \textbf{Listener}.
	\end{itemize}
	\itemBold{Taxi Driver View}
	In questo componente sono raggruppati i seguenti sotto componenti:
	\begin{itemize}
		\itemBold{TD Application View} E' il componente software che permette di intercettare gli eventi di interazione tra software e il \textbf{Taxi Driver}, come ad esempio click di un pulsante o lo scroll. 
		Inoltre è in grado di mostrare i dati di risposta ricevuti via rete.
		\itemBold{TD Request Creator} vedi \textbf{PS Request Creator}.
		\itemBold{TD Receiver} vedi \textbf{PS Receiver}
		\itemBold{TD Locator} E' il componente software che ha accesso all'interfaccia con il GPS dello smartphone del \textbf{Taxi Driver} e che, una volta invocato dal \textbf{Location Manager}, può richiedere al GPS la posizione di un determinato tassista. 
		E' fondamentale nel momento in cui il server, per avere una modello sempre consistente con la posizione reale dei tassisti, invia richieste di aggiornamento del mapping tra tassita e zona della città.
	\end{itemize}	
	\itemBold{Taxi Driver Model}
	In questo componente sono raggruppati i seguenti sotto componenti:
	\begin{itemize}
		\itemBold{GPS Data Source} E' un oggetto che rappresenta la posizione più recente inviata dal segnale GPS; è composto da molti dati, tra i quali i più imporntanti sono \textbf{Latitudine} e \textbf{Longitudine}.
		Infatti tramite questi dati è possibile determinare univocamente la posizione del \textbf{Taxi Driver}.
	\end{itemize}
	
	\itemBold{Controller}
	In questo componente sono raggruppati i seguenti sotto componenti:
	\begin{itemize}
		\itemBold{RESTful Service} Questo \textbf{Software Component} si occupa di ricevere le richieste dai \textbf{Client} e le distribuisce ai vari \textbf{Manager Components} appartententi alla \textbf{Busines Family}. 
		Inoltre garantisce che vengano gestite un numero massimo, prefissato e configurabile di richieste in parallelo.
		Per permettere agli altri \textbf{Software Components} di interagire espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Receive TD Request} Permette ai \textbf{Client} di inviare le richieste.
			\itemBold{Receive PS Request} vedi \textit{Receive TD Request}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Login} Utilizzata per gestire una richiesta di login proveniente dal PS.
			\itemBold{Logout} Utilizzata per gestire una richiesta di logout proveniente dal PS.
			\itemBold{Register} Utilizzata per gestire una richiesta di registrazione proveniente dal PS.
			\itemBold{Modify Profile} Utilizzata per gestire una richiesta di modifica del profilo proveniente dal PS.
			\itemBold{Report Problem} Utilizza questa interfaccia per gestire una richiesta di report problem proveniente dal TD.
			\itemBold{Add Taxi Ride} Utilizza questa interfaccia per gestire una richiesta di Taxi Ride proveniente dal PS.
			\itemBold{Remove Taxi Ride} Utilizza questa interfaccia per gestire una richiesta di cancellazione della Taxi Ride proveniente dal PS.
		\end{itemize}

		\itemBold{Dispatcher} Questo \textbf{Software Component} si occupa di dispacciare i messaggi di notifica, di sistema, di associazione tra \textbf{Taxi Ride} e \textbf{Taxi Driver} dal \textbf{Server} verso il relativo \textbf{Client}.
		Per permettere agli altri \textbf{Software Components} di interagire espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Dispatch Message} Permette ai componenti interni al \textbf{Controller} di inviare messaggi ai \textbf{Client}. 
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Receive PS Update} Utilizza questa interfaccia per permettere ai \textbf{Clients} di ricevere messaggi provenienti dai componenti interni al \textbf{Controller}.
			\itemBold{Receive TD Update} vedi \textit{Receive TD Update}.	
		\end{itemize}
		
		\itemBold{Location Manager} Questo \textbf{Software Component} espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Get Zone From Address} Permette di associare una \textit{city zone} a partire da un \textit{city address}, utile quando bisogna categorizzare una \textbf{Taxi Ride} appena arrivata.
			\itemBold{Get TD Address} Fornisce la funzionalità per richiedere ad un \textbf{Taxi Driver} il \textit{actual city address}, per aggiornare la mappa interna al server tra \textbf{Taxi Driver} e \textbf{City Address}.
			\itemBold{Compute Travel Time} Permette di calcolare il tempo di percorrenza tra due \textit{city addresses}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Get TD Position} Utilizza questa interfaccia per richiedere la posizione GPS al \textbf{Taxi Driver} che viene scelto dal \textbf{Taxi Driver Manager}.
			\itemBold{Google Maps API} Utilizza questa interfaccia per effettuare le richieste necessarie per calcolare il \textbf{Travel Time} e per associare un indirizzo ai dati GPS.	
		\end{itemize}
		
		\itemBold{Queue Manager} (il td manager avvisa q manager che un td ha cambiato zona e il q manager provvede a spostare il td nella coda della zona attuale del td)
		\itemBold{Queue Manager} Questo \textbf{Software Component} si occupa di :
		\begin{itemize}
			\item Gestire le code dei \textbf{Taxi Driver}, una coda per zona della città.
			\item Genera i messaggi di notifica ,contenenti \textit{Taxi Driver ID} e \textit{Travel Time}, da inviare ai \textbf{Passenger} nel momento in cui la richiesta che hanno fatto viene accettata da un \textbf{Taxi Driver}. 
			Per fare questo deve chiamare il \textbf{Location Manager} e richiedere il \textbf{Travel Time}.
			\item Provvede a cambiare la coda del \textbf{Taxi Driver} che ha cambiato zona.
			\item Ridistribuisce le\textbf{Taxi Ride}. Infatti quando viene servita una richiesta di \textbf{taxi rideTaxi Ride} associata ad una zona la cui relativa coda è vuota, scatta un timeout dopo la scadenza del quale la taxi ride viene ridistribuita in una delle code delle zone ad essa limitrofe.
		\end{itemize}
		Per performare queste funzionalità il \textbf{Queue Manager} espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{TD Zone Changed} Permette di cambiare coda ad un certo \textbf{Taxi Driver}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Query Queue Model} Utilizza questa interfaccia sul \textbf{Model} per spostare un \textbf{Taxi Driver} da una coda ad una altra coda quando quest'ultimo ha cambiato zona. 
			Inoltre questa interface ha un metodo per prelevare un \textbf{Taxi Driver} da una coda per associarlo ad una \textbf{Taxi Ride}.
			\itemBold{Compute Travel Time} Utilizza questa interfaccia per richiedere al \textbf{Location Manager} il \textbf{Travel Time} relativo ad una \textbf{Taxi Ride} che sta servendo.
			\itemBold{Dispatch Message} Utilizza questa interfaccia per inviare una notifica per confermare l'associazione di una \textbf{Taxi Ride} con un \textbf{Taxi Driver}.
		\end{itemize}
		
		\itemBold{Session Manager} E' il componente software che si occupa di modificare il modello relativo alle sessioni attive degli utenti di \myTaxiService{}.
		Per performare queste funzionalità il \textbf{Session Manager} espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Login} Permette di cambiare iniziare la procedura di login per un utente di \myTaxiService{}.
			\itemBold{Logout} Permette di cambiare iniziare la procedura di logout per un utente di \myTaxiService{}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Query Passenger Model} Utilizza questa interfaccia sul \textbf{Model} per modificare il modello aggiungendo una sessione per il \textbf{Passenger} che ha chiesto di fare login e restituendo un Token che identifichi la sessione appena aperta.
			\itemBold{Query Taxi Driver Model} Utilizza questa interfaccia sul \textbf{Model} per modificare il modello aggiungendo una sessione per il \textbf{Taxi Driver} che ha chiesto di fare login e restituendo un Token che identifichi la sessione appena aperta.
		\end{itemize}
		
		\itemBold{Profile Manager} Si occupa di modificare la porzione del modello relativa al profilo degli utenti registrati a \myTaxiService{}.
		Per performare queste funzionalità il \textbf{Profile Manager} espone le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Register} Permette di effettuare la registrazione a \myTaxiService{}.
			\itemBold{Modify Profile} Permette di modificare un profilo precedentemente creato presso \myTaxiService{}.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{Query Passenger Model} Utilizza questa interfaccia sul \textbf{Model} per modificare il modello aggiungendo un utente registrato o modificare il profilo di un utente precedentemente registrato.
		\end{itemize}
		
		\itemBold{Taxi Driver Manager} inviare ride ai tassisti, aggiornare la posizione, notifica il Queue manager di spostare un td.
		\itemBold{Taxi Driver Manager} Si occupa di gestire tutto ciò che riguarda i \textbf{Taxi Driver}. In particolare espone le seguenti interfaces:
		\begin{itemize}
			\itemBold{Report Problem} Permette ad un \textbf{Taxi Driver} di notificare l'avvenimento di un problema durante una \textbf{Taxi Ride} o di notificare che un certo probema è stato risolto.
		\end{itemize}
		Inoltre utilizza le seguenti \textit{interfaces}:
		\begin{itemize}
			\itemBold{TD Zone Changed} Utilizza questa interfaccia per notificare al \textbf{Queue Manager} di spostare un \textbf{Taxi Driver} da una coda ad un'altra perchè il relativo \textbf{Taxi Driver} ha cambiato zona.
			\itemBold{Query Taxi Driver Model} Utilizza questa interfaccia sul \textbf{Model} per modificare il modello nei seguenti casi: 
			\begin{itemize}
				\item Dopo aver ricevuto l'aggiornamento riguardante l'indirizzo di un \textbf{Taxi Driver} viene chiamato un metodo per aggiornare l'indirizzo nella base di dati.
				\item Per aggiungere un problema alla lista dei problemi.
				\item Per marcare un problema come risolto.
			\end{itemize}
			\itemBold{Dispatch Message}
			\itemBold{Get TD Address}
		\end{itemize}
		
		\itemBold{Taxi Ride Manager}
		\itemBold{Taxi Sharing Manager}
		This component is in charge of managing the Taxi Sharing
		\itemBold{Query Manager}
	\end{itemize}
	
	\itemBold{Model}
	In this component are included the following subcomponents:
	\begin{itemize}
		\itemBold{Model Query Service}
		This component provides an aggregated interface rich of methods to access the relational model underlying with a high level of abstraction, protection and security.
		The interface that it implements is called Query Model and it is used by the Query Manager to query the model via RPC.
		\itemBold{Passenger DB Adapter}
		It is a utility component that implements and exposes Passenger related query methods, built above the Query Database interface to the Database Driver Adatper.
		\itemBold{Taxi Ride DB Adapter}
		It is a utility component that implements and exposes Taxi Ride related query methods, built above the Query Database interface to the Database Driver Adatper.
		\itemBold{Taxi Driver DB Adapter}
		It is a utility component that implements and exposes Taxi Driver related query methods, built above the Query Database interface to the Database Driver Adatper.
		\itemBold{Zone DB Adapter}
		It is a utility component that implements and exposes Zone related query methods, built above the Query Database interface to the Database Driver Adatper.
		\itemBold{Queue DB Adapter}
		It is a utility component that implements and exposes Queue related query methods, built above the Query Database interface to the Database Driver Adatper.
		\itemBold{Database Driver Adapter}
		This component is a wrapper built on the Database Driver (that can be JDBC) that provides a set of methods to perform the common operations that could be done on a relational database.
		In fact it connects to the Database Management System via a Database Driver.
		Those methods are exposed in a interface that is called Query Database, and the various DB Adapters calls them in a way that depends on the caller component itself.
	\end{itemize}
\end{itemize} 
\subsubsection{UML Component Diagram}
%TODO ale inserisci il diagramma che non posso compilare e non posso vedere la preview

\subsection{Deployment view}
%TODO inserire il deployment diagram (spiega la suddivisione in tier). spiegazione dei tier hardware

\subsection{Runtime view}
%TODO You can use sequence diagrams to describe the way components interact to accomplish specific tasks typically related to your use cases.
\subsection{Component interfaces}
%TODO web socket porte https. come funzionano le interfacce tra componenti, perchè le abbiamo scelte e che vantaggi portano all'architettura che abbiamo scelto.
Being our system composed of different software components that need to interact together, several interfaces have been put among them.
Subsequently are listed all the main software components and their interfaces, each one described in detail:
\begin{itemize}
	\itemBold{Passenger View}
	This component implements 1 interface:
	\begin{itemize}
		\itemBold{Receive PS Update} An interface over the \textbf{Web Socket} technology that is implemented by the \textbf{Passenger View} and called by the \textbf{Controller} in order to deliver updates to a particular Passenger.
		It is required that a \textbf{Web Socket} is opened by the \textbf{Passenger View} to the \textbf{Controller} in order to permit the last one the sending of messages.
		Message delivery is intended to be asynchronous but in some cases the \textbf{Controller} waits the \textbf{Passenger View} to respond with some kind of information to a particular message sent to it, and in this case the communication is synchronous.
	\end{itemize}
	This component utilizes 1 interface:
	\begin{itemize}
		\itemBold{Receive PS Request} An interface implemented by the \textbf{Controller} that exposes the necessary methods to build up a \textbf{RESTful Service} over the \textbf{HTTPS} protocol.
		Through this interface the \textbf{Passenger View} can send specific requests to the \textbf{Controller}, that synchronously responds with the necessary information.
	\end{itemize}
	\itemBold{Taxi Driver View}
	This component implements 2 interfaces:
	\begin{itemize}
		\itemBold{Receive TD Updated} As for the \textbf{Receive PS Update} interface, this interface over \textbf{Web Socket} technology is called by the \textbf{Controller} to deliver messages and requests to a particular Taxi Driver.
		It is required that a \textbf{Web Socket} is opened by the \textbf{Taxi Driver View} to the \textbf{Controller} in order to permit it to send messages.
		The delivery of message is asynchronous when a direct answer by the \textbf{Taxi Driver View} is not needed, in other cases the \textbf{Controller} makes a synchronous call to the \textbf{Taxi Driver View} and waits for it to send back the desired data.
		\itemBold{Get TD Position} This interface over \textbf{Web Socket} is called synchronously by the \textbf{Controller} to get the last position registered in the \textbf{Taxi Driver View}.
		This could be a crucial part of the system and therefore it is intended that no Taxi Driver hacks his own smartphone GPS location system in order to deliver wrong position (maybe introducing an important fee to be paid in case of this misbehaviour).
		The \textbf{Taxi Driver Web} must open a \textbf{Web Socket} connection to the \textbf{Controller} in order to permit him to ask the position.
	\end{itemize}
	This component utilizes 2 interfaces:
	\begin{itemize}
		\itemBold{Receive TD Request} An interface over \textbf{HTTPS} that is implemented by the \textbf{Controller} and like the \textbf{Receive PS Request} does for the Passenger, allows the Taxi Driver to send request to the \textbf{Controller}, while waiting synchronously for a response.
		\itemBold{Get GPS Data} An interface implemented by the \textbf{Taxi Driver Model}, and is used to obtain the latest valid GPS position when the \textbf{Controller} asks for it via the \textbf{Get TD Position} interface.
		It can be easily seen as an abstraction over the operating system GPS drivers.
	\end{itemize}
	\itemBold{Taxi Driver Model}
	This component implements 1 interface:
	\begin{itemize}
		\itemBold{Get GPS Data} That is the interface offered to the \textbf{Taxi Driver View} and it is needed to obtain the most recent GPS position located by the GPS antenna installed in the Taxi Driver smartphone.
		In facts it wraps up the operating system GPS drivers in order to deliver a clean and meaningful interface to be utilized in the system to be.
	\end{itemize}
	\itemBold{Administration View}
	This component utilizes 1 interface:
	\begin{itemize}
		\itemBold{Administrator Queries} This interface is provided by the \textbf{Controller} via \textbf{RPC} technology (whose implementation could be \textbf{RMI}) and allows the \textbf{Administrator View} to perform some crucial activities and queries on the \myTaxiService{} model in a more direct and powerful way. Through this interface it is allowed the registration of a new Taxi Driver.
		This interface is not intended to be publicly accessible, and therefore it is better not to expose it through a public IP.
		In addition, it is intended that the Administrators are trained personnel and are very discouraged to damage or break the system they are interacting with.
	\end{itemize}
	\itemBold{Model}
	This component implements 1 interface:
	\begin{itemize}
		\itemBold{Query Model} It is an interface over \textbf{RPC} technology (could as well be \textbf{RMI}) that allows the \textbf{Controller} to do all kind of interesting relational queries on the \myTaxiService{} model, through a set of exposed and controlled methods.
		It abstracts the concept of relational query to a higher level of usability and security.
		The model to which the interface refers is at its core a relational database, that is accessed through a \textbf{Database Driver Adapter}, that could wrap up a database driver like \textbf{JDBC}.
	\end{itemize}
	\itemBold{Controller}
	This is the central part of \myTaxiService{} system and has the greatest number of implemented and utilized interfaces.
	It implements 4 different interfaces:
	\begin{itemize}
		\itemBold{myTaxiSharing API} This interface provided through \textbf{HTTPS} is intended to be utilized by the developers that wants to further develop \myTaxiService{}, adding the Taxi Sharing capability.
		It is not intended to be accessible publicly and therefore it must be protected using firewalls and access control management, with credential authentication.
		A developer that wants to utilize the API, must request the permission to the Administrator, that creates valid credentials, configures the system accordingly, and communicate to him/her those credentials.
		\itemBold{Receive PS Request} Already presented above in \textbf{Passenger View} interfaces analysis.
		\itemBold{Receive TD Request} Already presented above in \textbf{Taxi Driver View} interfaces analysis.
		\itemBold{Administrator Queries} Already presented above in \textbf{Administrator View} interfaces analysis.
	\end{itemize}
\end{itemize}
\subsection{Selected architectural styles and patterns}
%TODO Please explain which styles/patterns you used, why, and how
Several architectural styles and patterns were chosen in order to build \myTaxiService{} as a modern software.
The main pattern that were recursively adopted is the Model View Controller architectural pattern:
\begin{itemize}
	\itemBold{System Level} All the clients that use \myTaxiService{}, the Passengers, the Taxi Drivers, and the Administrator, are seen as Views, that following the Cocoa MVC pattern, connects to a Controller, the Web Server or the Application Server, that is itself connected to the Model that is hosted on the Database Server.
	\itemBold{Client Level} The views in the various clients are designed internally to conform to the MVC pattern. For instance the Passenger View is composed by a Model that is an internal representation of the data received by the Web Server, a Controller that performs network activities and connects to the Model and to the View, and the View that is either a Mobile Application GUI or a Web Page.
	\itemBold{Server Level} The server part of \myTaxiService{} is divided also physically into the three different entities of the MVC pattern:
	\begin{itemize}
		\itemBold{Web Server} It is the View of the server part of the application, and gives to clients a representation of the internal data. The Web Server is connected only to the Application Server. It contains all the assets included in the web portal. On its external interface, it can handle properly HTTPS requests and manage communication over Web Sockets. On its internal interface it sends and receives objects via RPC from the Application Server, that is in charge of the application logic.
		\itemBold{Application Server} That is the Controller of the server and connects to the Web Server and the Database Server via RPC. It contains most of the business logic behind \myTaxiService{} and therefore it is a core part of the system. It should be reachable only within the enterprise network, and not via public IP. The connection to the Web Server is used to receive requests and deliver responses to clients and to send asynchronous requests to them, when it is needed. On the other hand, the connection to the Database Server is necessary to connect the Controller to the Model, and it is used to store all the important data and react to some data modifications that occurs during the execution of the application.
		\itemBold{Database Server} It is the Model of the server, and infact the Model of the whole \myTaxiService{} system. It relies on an RPC connection with the Application Server and it is not directly reachable via a public IP. The Database Server is connected to a relational database via a Database Driver Adapter, that is a wrapper built over the DBMS installed on the Database Server Operating System. Following the Cocoa MVC pattern, it is not directly connected to the View of the server, that is the Web Server, but only to the Controller, that is the Application Server.
	\end{itemize}
\end{itemize}
Alongside the MVC architectural pattern, also the Client Server style is used for all the requests done by the various clients that can connect to the Web Server of \myTaxiService{}. The Taxi Driver Application and the Passenger Application can use a standardized Client Server protocol via HTTPS that is follows the principle of a RESTful service. The Administrator application its connected via RPC to the Web Server and can perform more critical requests, like the registration of a new Taxi Driver into the system. It is required that the Administrator application opens a RPC connection to the server to start the communication.
A Point to Point bidirectional messaging system is established between the clients and the Web Server at the startup of the client application. The client should explicitly request a connection to the server that is listening for clients to connect. It is a connection over Web Socket that allows the Web Server to send asynchronous messages and requests to which the client can respond using the same channel. It's main functions are the one that allows the server to send a Taxi Ride proposal to a given Taxi Driver, that can either accept or deny the proposal, and the one that allows the server to ask the Taxi Driver an updated geolocalization data.
The Client Server style and Point to Point bidirectional messaging system are used to implement properly the MVC pattern in this three layers, four tiers system.
The three layers have already been discussed and are:
\begin{itemize}
	\itemBold{Data Layer} That is the System Level Model
	\itemBold{Business Logic Layer} That is the System Level Controller
	\itemBold{Presentation Layer} That is the System Level View
\end{itemize}
These layer, as already said, are mapped into four different tiers:
\begin{itemize}
	\itemBold{Clients} They map the System Level View.
	\itemBold{Web Server} It maps a portion of the System Level Controller, that is the one of the RESTful Service, Dispatcher, and part of the Location Manager, onto software objects that provide the required network capabilities.
	\itemBold{Application Server} This tier maps the purely logic part of the System Level Controller.
	\itemBold{Database Server} It maps the System Level Model.
\end{itemize}
\subsection{Other design decisions}
There have been chosen several technologies that best fit the needs of the system to be. Not all the required functionalities of \myTaxiService{} are already mapped onto specific products because in those cases the choice done would matter less.
But for the cases in which a technology has already been proposed, it is because a clear design decision was mandatory.
As for the communication protocols between clients (excluded the Administrator client) and the server have been chosen:
\begin{itemize}
	\itemBold{HTTPS} The secure version of HTTP was a mandatory choice as security and privacy concerns are of major importance nowadays.
	\itemBold{Web Socket} This innovative socket technology has been chosen although is relatively new because it implements a full duplex socket communication channel using web technology and therefore using the port 80, which is in almost every case not blocked by any firewall.
\end{itemize}
For what concerns the network reachability has been chosen to make discoverable only the Web Server through the assignment to it of a public IP.
All the other servers in \myTaxiService{} system should be reachable only within the enterprise network.
Between the Web Server and the external network is installed a firewall that controls all the incoming connections.
In particular it must accept only incoming HTTPS connections, Web Socket connections and RPC connections.
A firewall is also used to protected the Database Server from the Application Server in the unlikely case that the Application Server is attacked through the Web Server or the Application Server for some reasons stops working correctly and start behaving in a way that will damage the application Model.
Also, another interesting design choice that has been made concerns the way in which the GPS coordinates obtained from a given Taxi Driver are mapped into a specific Zone.
It could have been possible, but not feasible, to do such a thing:
\begin{enumerate}
	\item Obtain GPS Data via Web Socket from the selected Taxi Driver
	\item Calculate the nearest Address of the given GPS Data using Google Maps HTTPS API
	\item Query the Model to obtain the Zone to which belongs the given Address
\end{enumerate}
But this solution required to have a precomputed data structure that associate every Address in the City to the corresponding Zone (that could have been a relational table with as many tuples inside as Addresses in the City), that is heavy to manage and mantain, although if correctly installed and filled, it gives for certain good performances.
A less heavy weight solution has been found and that is a solution that expects every Zone of the city to be divided in several convex Polygon, for instance Triangles, that have interesting properties for our application.
The polygonal shape of the Zone could be almost as complex as one can imagine and be decomposed in a finite number of Triangles in all the interesting applications.
In \myTaxiService{} Zones of regular shape are intended to be used, and therefore the number of Triangles in which a Zone will be decomposed is limited.
So such a flow is followed:
\begin{enumerate}
	\item Obtain GPS Data via Web Socket from the selected Taxi Driver
	\item For each Zone, check if the the Point that the Longitude and Latitude from GPS Data identify is contained inside any Triangle in which the Zone is divided. If that is true, that the Zone is found. If that is false, than another Zone could contain the given Point. If no Zone contains the Point, then we can assume that the Point refers to GPS Data that locate a geographical point outside of the City.
\end{enumerate}
The computation of the Point in Triangle test is simple and efficient and an algorithm implementation in Java is provided in the following section.
