\documentclass{../common/latex_classes/pdf_presentation}

\title{ID Presentation}

\subject{A brief presentation of the Inspection Document}
% This is only inserted into the PDF information catalog. Can be left
% out. 

% Let's get started
\begin{document}
	\titleToc{}
		\section{Class Name and Pattern Explanation}
		
		\begin{frame}{IIOPSSLSocketFactory - Overview}
			The class we have been assigned is named \textbf{IIOPSSLSocketFactory}.
			It is included in the \textbf{org.glassfish.enterprise.iiop.impl} package.
			\textbf{IIOPSSLSocketFactory} implements the \textbf{ORBSocketFactory} interface, which is part of the \textbf{CORBA} (Common Object Request Broker Architecture) standard declined to \textbf{Java Enterprise Edition}.
		\end{frame}
		
		\begin{frame}{IIOPSSLSocketFactory - ORB}
			The \textbf{ORBSocketFactory} interface is included in the \textbf{com.sun.corba.ee.spi.transport} package, and is an interface that abstracts some parts of the \textbf{ORB} (Object Request Broker) middleware related to sockets creation.
			As the name suggests, the \textbf{ORBSocketFactory} interface is a \textbf{Factory} of \textbf{Sockets} for the \textbf{ORB} middleware.
		\end{frame}
		
		\begin{frame}{IIOPSSLSocketFactory - IIOP}
			The \textbf{IIOP} (Internet Inter-ORB Protocol, a concrete protocol) is an implementation of the \textbf{GIOP} (General Inter-ORB Protocol, an abstract protocol) that \textbf{ORB}s use to communicate over the Internet, and provides a mapping between \textbf{GIOP} messages and the \textbf{TCP/IP} layer.
			Our class is therefore a \textbf{Factory} of \textbf{SSLSockets} for \textbf{IIOP}, and is an \textbf{Implementation} of the relevant part of the \textbf{IIOP} included in the \textbf{Enterprise} facilities of the \textbf{GlassFish} server.
		\end{frame}
		
		\section{Functional Role of Assigned Class}
		
		\subsection{ORB Middleware}
		
		\begin{frame}{ORB Middleware - Overview}
			%First of all, an overview of the \textbf{ORB} middleware is given, because it is the component that uses the \textbf{IIOP} protocol to communicate over the Internet.
			The \textbf{O}bject \textbf{R}equest \textbf{B}roker
			(component that uses the \textbf{IIOP} protocol) 
			allows method calls to be made from one computer to another via network. \par This middleware allows objects to interact in a \textbf{heterogeneous}, \textbf{distributed} environment, \textbf{independent} of the \textbf{computer platforms} on which the various objects reside and the \textbf{languages} used to implement them. \par \textbf{For example}, a C++ object running on one machine can communicate with an object on another machine which is implemented in Java. 
			
		\end{frame}
			
		\begin{frame}{ORB Middleware - Actors}
			
			\textbf{Two} main actors are involved in this new \textbf{Client - Server} approach, called \textbf{CORBA Client - Server architecture}:
			\begin{itemize}
				\item \textbf{Client:}
				It requests a method call to an object which interface (stub) is exposed by the \textbf{Server} and is known to the \textbf{Client}.(In Java RMI this is done by the client by looking up on a registry, where the server puts the remote objects).
				The \textbf{Client} has the capability of sending some parameters to the Server for executing the given method call and the capability of receiving back the return value of the called method, if any.
				\item \textbf{Server:}
				It exposes the interfaces of the objects that can be called by the various \textbf{Clients} allowed to make remote method calls.
				Through those interfaces, the \textbf{Clients} can make remote method calls, passing objects as parameters if necessary, and receiving a return value, if any.
			\end{itemize}
		\end{frame}
		
		\begin{frame}{CORBA Client - Server Architecture}
			\showPercentImage{./section_2/iiop.jpg}{Overview of CORBA Architecture}{0.9}
		\end{frame}
		
		\subsection{Functional Role}
		
		\begin{frame}{Class functionalities - Socket Creation}
			The class has a lot of roles including the creation of \textbf{Sockets}.\par Through two methods, of whom one calls the other one, the class can create \textbf{two type of socket}:
			\begin{itemize}
				\item \textbf{Plain Socket:}
				Plain Text Socket (\textbf{java.net.Socket}) with \textit{Nagle's algorithm disabled}.
				\item \textbf{Secure Socket:}
				Encrypted Socket (\textbf{javax.net.ssl.SSLSocket}) that uses \textbf{Secure Socket Layer} or \textbf{Transport Secure Layer}.
				Its characteristics are defined during the creation of a \textbf{IIOPSSLSocketFactory} object by \textit{obtaining data from global variables} (which seems to be a bad behaviour) and storing those data into a specific private attribute of type \textbf{IIOPSSLSocketFactory.SSLInfo}.
				%This private attribute is never modified after \textbf{IIOPSSLSocketFactory} object creation and thus it can be considered as final, although it is not declared final nor immutable.
				In particular, a secure socket built by \textbf{IIOPSSLSocketFactory} can use either one of the following cryptographic protocols for data encryption: \textbf{SSL1}, \textbf{SSL2}, \textbf{SSL3}, \textbf{TLS}.
			\end{itemize}
		\end{frame}
		
		\begin{frame}{Class functionalities - Server Socket Creation}
			This functionality allows the creation of a \textbf{Server Socket}.
			\begin{itemize}
				\item \textbf{Plain Server Socket:}
				A Server Socket (\textbf{java.net.ServerSocket}) that accepts incoming \textbf{Plain Socket} connections from \textbf{Clients}.
				\item \textbf{Secure Server Socket:}
				A Secure Server Socket (\textbf{javax.net.ssl.SSLSocket}) that accepts incoming \textbf{Secure Socket} connections.
				%on a certain \textbf{Port} of a given \textbf{IP} address.
				Given that the class can open a \textbf{Server Socket} for each \textbf{IIOP Listener}, in the boot procedure it stores in a \textbf{java.util.Map} an association between the a given \textbf{TCP Port} and an object, called \textbf{SSLInfo} object, that summarized the informations about an opened \textbf{IIOP Listener}.
				
				From this map could be derived the association between every \textbf{IIOP Listener Port} to the relevant \textbf{IIOP Listener configuration}.
				
				Once required, the server socket related to an \textbf{IIOP Listener} can be opened, and the server can accepts incoming connections from the remote \textbf{Clients} of \textbf{Enterprise Beans} and from other \textbf{CORBA}
				%(Common Object Request Broker Architecture)
				based \textbf{Clients}.
			\end{itemize}
		\end{frame}
		
		\begin{frame}{Class Context}
			The entire class behaviour depends on the type of process wherein the \textbf{IIOPSSLSocketFactory} object is built (A extremely bad modus operandi).
			Inferring the source code available there can exists two different types of processes in which this class could be used:
			\begin{itemize}
				\item \textbf{EJB container:} In this case the object is instantiated in a \textbf{Server Process}
				%The \textbf{EJB container} is the interface between \textbf{enterprise beans}, which provide the business logic in a \textbf{Java EE application}, and the \textbf{Java EE server}. (Server Process)
				\item \textbf{Application Client Container:}
				In this case the object is instantiated in a \textbf{Client Process}.
				%The \textbf{Application Client Container} is the interface between \textbf{Java EE application clients} (special Java SE applications that use Java EE server components) and the \textbf{Java EE server}. The \textbf{application client container} runs on the \textbf{client machine} and is the gateway between the \textbf{client application} and the \textbf{Java EE server components} that the client uses. (Client Process)
			\end{itemize}
			Through the use of an \textbf{If - Else Structure} in the \textbf{class's Constructor}, the created object derived by the \textbf{if branch} is completely different from the \textbf{else one}.
			
			\end{frame}
			
			\begin{frame}{Class Usage}
			To recap, the functional role is either one of the following two:
			\begin{itemize}
				\item \textbf{EJB Container Functional Role:}
				The \textbf{Server Socket Creation} functionality is used to give a \textbf{IIOP Listener} the capability of accepting incoming \textbf{Plain Text Socket} and \textbf{Secure Socket} connections, in order to receive \textbf{Remote Method Calls} through \textbf{IIOP}.
				On the other side, the \textbf{Socket Creation} capability is exploited when the \textbf{EJB Container} needs to make \textbf{Remote Method Calls} using \textbf{IIOP} to another remote \textbf{EJB Container}.
				\item \textbf{Application Client Container Functional Role:}
				The \textbf{Socket Creation} functionality is used to connect to a remote \textbf{IIOP Listener} that is running into an \textbf{EJB Container} in order to deliver a \textbf{Remote Method Call}, and receive the \textbf{Return Value}, if any.
			\end{itemize}
		\end{frame}
	
	\section{Issues Found}
	
	\subsection{Class Issues}
	
	\begin{frame}{Class Issues - Overview}
		In this subsection are listed the issues related to the whole class and not only to a specific method. \par Below we propose only few \textbf{selected}, \textbf{particular} and \textbf{meaningful} issues that we have thought could have been interesting to be spoken about.
	\end{frame}
	\begin{frame}{Class Issues - Checklist[1] Naming Conventions}
		The class has the capability of creating also \textbf{Plain Text Socket} and \textbf{Plain Text Server Socket}, even if the name \textbf{IIOPSSLSocketFactory} clearly underlines that the class has to be a Factory of \textbf{Secure Sockets and Server Sockets}. In order to give the architecture the ability of creating \textbf{Plain Text Socket} and \textbf{Plain Text Server Socket}, a separate class has to be thought.
	\end{frame}
	\begin{frame}{Class Issues - Checklist[18] Comments}
		The class is not adequately commented at all.
	\end{frame}
	\begin{frame}{Class Issues - Checklist[20] Java Source File}
		The main class contains an internal class named \textbf{SSLInfo}.
	\end{frame}
	\begin{frame}{Class Issues - Checklist[27] Class and Interface Declarations}
		The constructor \textbf{IIOPSSLSocketFactory()} is \textbf{75 lines of code long} and it is not easily comprehensible. Furthermore it is full of if - else structures with no meaningful conditions. A such long method worsens the readability and the instant comprehension of the method’s role in the code. In addition it would be better to \textbf{refactor} and separate the atomic parts of code in additional methods.
	\end{frame}
	\begin{frame}{Class Issues - Checklist[28] Initialization and Declarations}
		\textbf{Lines 94 to 97:} The private variables \textbf{TLS, SSLv3, SSLv2, SSL} are used as simple string instead of creating an enumeration for better show the logic bond between each one and the other ones.
		%\renderPartialCode{94}{97}
	\end{frame}
	\subsection{Method Issues}
	
	\begin{frame}{Method Issues - Overview}
		The \textbf{checklist} has also been checked analysing the assigned source code file method by method.
		We were assigned of \textbf{four methods} of this class:
		\begin{itemize}
			\itemBold{.createServerSocket()}
			\itemBold{.createSSLServerSocket()}
			\itemBold{.createSocket()}
			\itemBold{.createSSLSocket()}
		\end{itemize}
	\end{frame}
	
	\begin{frame}{.createServerSocket() Main Issues}
		Below we show the method's aspects we want to underline:
		\begin{itemize}
			\itemBold{Indention CL[8]} The whole method 	lacks a level of indentation and in general is provided of a bad layout (blank useless lines...).
			\itemBold{File Organization CL[12]} Lines 277, 289, 296 and 299 are blank without a clear reason.
			\itemBold{Comments CL[18]} The provided JavaDoc is too short and not really explicative. It does not completely explain the method functionalities.
			\itemBold{Computation, Comparisons and Assignments CL[44]} Lines 283 to 284: The if condition is not explicit and requires inference to be fully understood. In addition it is error prone. The whole problem should have been faced using an enumeration instead of String constants.
			\itemBold{Initialization and Declarations} In the method's code we can find some useless variable's initialization to \textit{"null"} value.
		\end{itemize}
	\end{frame}
	
	\begin{frame}{.createSocket() Main Issues}
		Below we show the method's aspects we want to underline:
		\begin{itemize}
			\itemBold{Indention CL[8]} The whole method 	lacks a level of indentation and in general is provided of a bad layout (blank useless lines...).
			\itemBold{File Organization CL[13]} Lines 304, 310, 317, 329 are too long.
			\itemBold{Comments CL[18]} The provided JavaDoc is too short and not really explicative. It does not completely explain the method functionalities.
			\itemBold{Initialization and Declaration CL[28]} At line 401 the variable \textit{ss} should have been declared of type \textbf{SSLServerSocket} instead of plain \textbf{ServerSocket}.
			\itemBold{Initialization and Declaration CL[29]} At lines 332, 332 the local variables host and port could have been used instead for better code readability.
			\itemBold{Exception CL[52]} Lines 340 to 345: The catch block is actually catching a generic Exception instead of the generated ones.

		\end{itemize}
	\end{frame}
	
	\begin{frame}{.createSSLServerSocket() Main Issues}
		Below we show the method's aspects we want to underline:
		\begin{itemize}
			\itemBold{}
		\end{itemize}
	\end{frame}
	
	\begin{frame}{.createSSLSocket() Main Issues}
		Below we show the method's aspects we want to underline:
		\begin{itemize}
			\itemBold{}
		\end{itemize}
	\end{frame}
	
\end{document}